/**
 * QI Research Pipeline - Document Agent
 *
 * This agent handles Stage 5 - Document Generation of the QI/Research Project
 * Development Pipeline. It determines required documents, generates content
 * using LLM, tracks documents in the database, and creates submission packages.
 *
 * @module agents/DocumentAgent
 *
 * @example
 * ```typescript
 * import { DocumentAgent } from '@/agents/DocumentAgent';
 * import { ProjectRepository, DocumentRepository, AuditRepository } from '@/db/repositories';
 *
 * const projectRepo = new ProjectRepository();
 * const documentRepo = new DocumentRepository();
 * const auditRepo = new AuditRepository();
 *
 * const documentAgent = new DocumentAgent(projectRepo, documentRepo, auditRepo);
 *
 * // Generate all documents for a project
 * const result = await documentAgent.generateDocuments('project-123');
 *
 * // Determine required documents
 * const requiredDocs = await documentAgent.determineRequiredDocuments(project);
 * ```
 */

import { v4 as uuidv4 } from 'uuid';

import {
  type Project,
  type DocumentsStageData,
  type GeneratedDocument,
  type DocumentMetadata,
  type DocumentSection,
  type DocumentValidationResult,
  type SubmissionChecklistItem,
  DocumentType,
  DocumentStatus,
  DocumentFormat,
  WritingStyle,
  SectionType,
  getRequiredDocuments,
  getWordLimit,
  countWords,
  exceedsWordLimit,
  generateFilename,
  EMF_WORD_LIMITS,
  PROTOCOL_WORD_LIMITS,
} from '../types/index.js';

import {
  complete,
  LLMError,
} from '../llm/index.js';

import {
  DOCUMENT_GENERATION_SYSTEM_PROMPT,
  generateSectionOutlinePrompt,
  convertToProseStylePrompt,
  parseDocumentOutlineResponse,
  type DocumentSectionInput,
  type DocumentOutlineOutput,
  type ProseConversionInput,
  type WritingStyle as PromptWritingStyle,
} from '../llm/prompts/index.js';

import type {
  ProjectRepository,
  DocumentRepository,
  AuditRepository,
  CreateDocumentDTO,
} from '../db/repositories/index.js';

// ============================================================================
// Types and Interfaces
// ============================================================================

/**
 * Document content generated by the agent
 */
export interface DocumentContent {
  /** Document type */
  type: DocumentType;
  /** Document title */
  title: string;
  /** Document sections with content */
  sections: DocumentSectionContent[];
  /** Total word count */
  totalWordCount: number;
  /** Validation result */
  validationResult: DocumentValidationResult;
  /** Metadata about generation */
  generationMetadata: {
    generatedAt: string;
    modelUsed: string;
    tokensUsed?: number;
  };
}

/**
 * Section content within a document
 */
export interface DocumentSectionContent {
  /** Section identifier */
  id: string;
  /** Section type */
  type: SectionType;
  /** Section title */
  title: string;
  /** Generated outline */
  outline: string;
  /** Generated prose content */
  content: string;
  /** Word count */
  wordCount: number;
  /** Word limit for section */
  wordLimit?: number;
  /** Order in document */
  order: number;
  /** Whether section is required */
  isRequired: boolean;
  /** Source data fields used */
  sourceFields: string[];
  /** Validation errors */
  validationErrors: string[];
}

/**
 * Validation result for document content
 */
export interface ValidationResult {
  /** Whether document passes validation */
  isValid: boolean;
  /** Validation errors (blocking) */
  errors: string[];
  /** Validation warnings (non-blocking) */
  warnings: string[];
  /** Section-specific validation */
  sectionValidation: Map<string, { isValid: boolean; issues: string[] }>;
}

/**
 * Configuration for document generation
 */
export interface DocumentGenerationConfig {
  /** Target writing style */
  style: WritingStyle;
  /** Target audience */
  targetAudience: string;
  /** Citation style to use */
  citationStyle: 'VANCOUVER' | 'APA' | 'HARVARD';
  /** Whether to include appendices */
  includeAppendices: boolean;
  /** Custom word limit overrides */
  wordLimitOverrides?: Record<string, number>;
}

// ============================================================================
// Document Agent Class
// ============================================================================

/**
 * Agent responsible for document generation in the QI/Research Pipeline
 *
 * Handles Stage 5 - Document Generation including:
 * - Determining required documents based on ethics pathway and grant target
 * - Generating document outlines using LLM
 * - Converting outlines to prose content
 * - Preparing content for template population
 * - Tracking generated documents in database
 * - Creating submission package metadata
 */
export class DocumentAgent {
  /** Project repository for data access */
  private readonly projectRepo: ProjectRepository;

  /** Document repository for document persistence */
  private readonly documentRepo: DocumentRepository;

  /** Audit repository for logging actions */
  private readonly auditRepo: AuditRepository;

  /** Default generation configuration */
  private readonly defaultConfig: DocumentGenerationConfig = {
    style: WritingStyle.SCIENTIFIC,
    targetAudience: 'Ethics committee and scientific reviewers',
    citationStyle: 'VANCOUVER',
    includeAppendices: true,
  };

  /**
   * Create a new DocumentAgent instance
   *
   * @param projectRepo - Repository for project data access
   * @param documentRepo - Repository for document persistence
   * @param auditRepo - Repository for audit logging
   */
  constructor(
    projectRepo: ProjectRepository,
    documentRepo: DocumentRepository,
    auditRepo: AuditRepository
  ) {
    this.projectRepo = projectRepo;
    this.documentRepo = documentRepo;
    this.auditRepo = auditRepo;
  }

  // ============================================================================
  // Main Document Generation Methods
  // ============================================================================

  /**
   * Generate all required documents for a project
   *
   * This is the main entry point for document generation. It:
   * 1. Retrieves the project and validates prerequisites
   * 2. Determines required documents based on ethics pathway and grant target
   * 3. Generates content for each document
   * 4. Validates generated content
   * 5. Saves documents to the database
   * 6. Creates submission package metadata
   *
   * @param projectId - ID of the project to generate documents for
   * @param config - Optional configuration overrides
   * @returns DocumentsStageData containing all generated documents
   *
   * @throws Error if project not found or prerequisites not met
   *
   * @example
   * ```typescript
   * const agent = new DocumentAgent(projectRepo, documentRepo, auditRepo);
   * const result = await agent.generateDocuments('project-123');
   * console.log(`Generated ${result.generated.length} documents`);
   * ```
   */
  async generateDocuments(
    projectId: string,
    config?: Partial<DocumentGenerationConfig>
  ): Promise<DocumentsStageData> {
    const mergedConfig = { ...this.defaultConfig, ...config };

    // Log start of document generation
    await this.auditRepo.logAction({
      projectId,
      action: 'DOCUMENT_GENERATION_STARTED',
      details: { config: mergedConfig },
    });

    try {
      // Retrieve and validate project
      const project = await this.projectRepo.findById(projectId);
      if (!project) {
        throw new Error(`Project not found: ${projectId}`);
      }

      // Validate prerequisites
      this.validatePrerequisites(project);

      // Determine required documents
      const requiredDocTypes = await this.determineRequiredDocuments(project);

      // Generate content for each document type
      const generatedDocuments: GeneratedDocument[] = [];
      const pendingReview: string[] = [];

      for (const docType of requiredDocTypes) {
        try {
          // Generate document content
          const content = await this.generateDocumentContent(project, docType, mergedConfig);

          // Validate the content
          const validationResult = await this.validateDocumentContent(content, docType);

          // Create document record in database
          const document = await this.saveDocument(projectId, content, validationResult);

          generatedDocuments.push(document);

          // Add to pending review if validation has warnings or errors
          if (!validationResult.isValid || validationResult.warnings.length > 0) {
            pendingReview.push(document.id);
          }

          // Log successful generation
          await this.auditRepo.logAction({
            projectId,
            action: 'DOCUMENT_GENERATED',
            details: {
              documentId: document.id,
              documentType: docType,
              wordCount: content.totalWordCount,
              isValid: validationResult.isValid,
            },
          });
        } catch (error) {
          // Log failure but continue with other documents
          await this.auditRepo.logAction({
            projectId,
            action: 'DOCUMENT_GENERATION_FAILED',
            details: {
              documentType: docType,
              error: error instanceof Error ? error.message : 'Unknown error',
            },
          });

          // Re-throw if it's a critical error
          if (error instanceof LLMError) {
            const llmError = error as LLMError;
            if (!llmError.retryable) {
              throw error;
            }
          }
        }
      }

      // Create submission package metadata
      const metadata = await this.createSubmissionMetadata(
        projectId,
        project,
        generatedDocuments,
        requiredDocTypes
      );

      // Compile final result
      const documentsStageData: DocumentsStageData = {
        generated: generatedDocuments,
        pendingReview,
        metadata,
      };

      // Update project with documents stage data
      await this.projectRepo.updateStageData(projectId, 'documents', documentsStageData);

      // Log completion
      await this.auditRepo.logAction({
        projectId,
        action: 'DOCUMENT_GENERATION_COMPLETED',
        details: {
          totalDocuments: generatedDocuments.length,
          pendingReview: pendingReview.length,
          totalWordCount: metadata.totalWordCount,
        },
      });

      return documentsStageData;
    } catch (error) {
      // Log overall failure
      await this.auditRepo.logAction({
        projectId,
        action: 'DOCUMENT_GENERATION_FAILED',
        details: {
          error: error instanceof Error ? error.message : 'Unknown error',
          stage: 'overall',
        },
      });

      throw error;
    }
  }

  /**
   * Determine required documents based on ethics pathway and grant target
   *
   * Analyzes the project's ethics pathway and grant target to determine
   * which documents must be generated for the submission package.
   *
   * @param project - The project to analyze
   * @returns Array of required document types
   *
   * @example
   * ```typescript
   * const requiredDocs = await agent.determineRequiredDocuments(project);
   * // Returns: [DocumentType.RESEARCH_PROTOCOL, DocumentType.HREC_COVER_LETTER, ...]
   * ```
   */
  async determineRequiredDocuments(project: Project): Promise<DocumentType[]> {
    const required: DocumentType[] = [];

    // Get ethics pathway
    const ethicsPathway = project.ethics?.ethicsPathway?.pathway;
    const grantTarget = project.intake.grantTarget;

    // Use utility function for base requirements
    if (ethicsPathway) {
      const baseRequired = getRequiredDocuments(ethicsPathway, grantTarget);
      required.push(...baseRequired);
    } else {
      // Fallback based on project type
      if (project.classification.projectType === 'QI') {
        required.push(DocumentType.QI_PROJECT_PLAN);
      } else {
        required.push(DocumentType.RESEARCH_PROTOCOL);
      }
    }

    // Add consent form if required
    if (project.ethics?.consentRequirements?.type !== 'NOT_APPLICABLE') {
      if (project.ethics?.consentRequirements?.type === 'WRITTEN_CONSENT') {
        if (!required.includes(DocumentType.PICF)) {
          required.push(DocumentType.PICF);
        }
      }
    }

    // Add data management plan if not already included
    if (project.ethics?.dataGovernance && !required.includes(DocumentType.DATA_MANAGEMENT_PLAN)) {
      required.push(DocumentType.DATA_MANAGEMENT_PLAN);
    }

    // Add timeline document
    if (!required.includes(DocumentType.TIMELINE)) {
      required.push(DocumentType.TIMELINE);
    }

    // Remove duplicates and return
    return [...new Set(required)];
  }

  /**
   * Generate content for a specific document type
   *
   * Generates the complete content for a document by:
   * 1. Determining the sections required
   * 2. Generating outlines for each section
   * 3. Converting outlines to prose
   * 4. Assembling the final document
   *
   * @param project - The project data
   * @param docType - Type of document to generate
   * @param config - Generation configuration
   * @returns Generated document content
   */
  async generateDocumentContent(
    project: Project,
    docType: DocumentType,
    config?: Partial<DocumentGenerationConfig>
  ): Promise<DocumentContent> {
    const mergedConfig = { ...this.defaultConfig, ...config };
    const sections: DocumentSectionContent[] = [];
    const sectionConfigs = this.getSectionConfigs(docType, project);

    let order = 0;
    for (const sectionConfig of sectionConfigs) {
      // Build source content from project data
      const sourceContent = this.buildSourceContent(project, sectionConfig.sourceFields);

      // Generate outline
      const outline = await this.generateSectionOutline(
        sectionConfig.name,
        {
          docType,
          sectionConfig,
          sourceContent,
          project,
        }
      );

      // Determine writing style for this section
      const style = this.getWritingStyleForSection(docType, sectionConfig.name, mergedConfig);

      // Convert outline to prose
      const prose = await this.convertOutlineToProse(outline, style);

      // Calculate word count
      const wordCount = countWords(prose);
      const wordLimit = sectionConfig.wordLimit ?? getWordLimit(docType, sectionConfig.name);

      // Check for validation issues
      const validationErrors: string[] = [];
      if (wordLimit && wordCount > wordLimit) {
        validationErrors.push(
          `Section exceeds word limit: ${wordCount}/${wordLimit} words (${wordCount - wordLimit} over)`
        );
      }

      sections.push({
        id: uuidv4(),
        type: sectionConfig.sectionType,
        title: sectionConfig.title,
        outline,
        content: prose,
        wordCount,
        wordLimit,
        order: order++,
        isRequired: sectionConfig.isRequired,
        sourceFields: sectionConfig.sourceFields,
        validationErrors,
      });
    }

    // Calculate total word count
    const totalWordCount = sections.reduce((sum, s) => sum + s.wordCount, 0);

    // Compile validation result
    const validationResult = this.compileValidationResult(sections, docType);

    return {
      type: docType,
      title: this.getDocumentTitle(docType, project),
      sections,
      totalWordCount,
      validationResult,
      generationMetadata: {
        generatedAt: new Date().toISOString(),
        modelUsed: process.env.LLM_MODEL || 'claude-sonnet-4-20250514',
      },
    };
  }

  /**
   * Generate an outline for a document section
   *
   * Uses LLM to create a structured outline based on source data,
   * document requirements, and reporting guidelines.
   *
   * @param sectionName - Name of the section to outline
   * @param sourceData - Source data for content generation
   * @returns Generated outline string
   */
  async generateSectionOutline(
    sectionName: string,
    sourceData: {
      docType: DocumentType;
      sectionConfig: SectionConfig;
      sourceContent: Record<string, unknown>;
      project: Project;
    }
  ): Promise<string> {
    const { docType, sectionConfig, sourceContent, project } = sourceData;

    // Map internal document type to prompt document type
    const promptDocType = this.mapToPromptDocumentType(docType);

    const input: DocumentSectionInput = {
      documentType: promptDocType,
      sectionName,
      sourceContent: {
        project: {
          intake: project.intake,
          classification: project.classification,
          frameworks: project.frameworks,
        },
        research: project.research as Record<string, unknown> | undefined,
        methodology: project.methodology as Record<string, unknown> | undefined,
        ethics: project.ethics as Record<string, unknown> | undefined,
      },
      wordLimit: sectionConfig.wordLimit,
      targetAudience: this.defaultConfig.targetAudience,
      reportingGuideline: project.frameworks?.reportingGuideline,
      citationStyle: this.defaultConfig.citationStyle,
    };

    const prompt = generateSectionOutlinePrompt(input);

    try {
      const response = await complete(prompt, {
        system: DOCUMENT_GENERATION_SYSTEM_PROMPT,
        temperature: 0.4,
        maxTokens: 2000,
      });

      // Parse the outline response
      const parsedOutline = parseDocumentOutlineResponse(response);

      // Convert structured outline to text format
      return this.formatOutlineToText(parsedOutline);
    } catch (error) {
      // Log error and return a basic outline structure
      console.error(`Error generating outline for ${sectionName}:`, error);

      // Return a fallback outline
      return this.generateFallbackOutline(sectionName, sourceContent);
    }
  }

  /**
   * Convert an outline to flowing prose content
   *
   * Uses LLM to transform structured outlines into publication-ready
   * prose that adheres to the specified writing style.
   *
   * @param outline - The outline to convert
   * @param style - Target writing style
   * @returns Generated prose content
   */
  async convertOutlineToProse(outline: string, style: WritingStyle): Promise<string> {
    // Map WritingStyle enum to prompt type
    const promptStyle = this.mapToPromptWritingStyle(style);

    const input: ProseConversionInput = {
      outline,
      style: promptStyle,
      citationStyle: this.defaultConfig.citationStyle,
    };

    const prompt = convertToProseStylePrompt(input);

    try {
      const response = await complete(prompt, {
        system: DOCUMENT_GENERATION_SYSTEM_PROMPT,
        temperature: 0.5,
        maxTokens: 4000,
      });

      return response.trim();
    } catch (error) {
      console.error('Error converting outline to prose:', error);

      // Return the outline as-is if conversion fails
      return outline;
    }
  }

  /**
   * Validate generated document content
   *
   * Checks document content against requirements including:
   * - Word limits
   * - Required sections
   * - Content completeness
   * - Formatting requirements
   *
   * @param content - Document content to validate
   * @param docType - Type of document being validated
   * @returns Validation result with errors and warnings
   */
  async validateDocumentContent(
    content: DocumentContent,
    docType: DocumentType
  ): Promise<ValidationResult> {
    const errors: string[] = [];
    const warnings: string[] = [];
    const sectionValidation = new Map<string, { isValid: boolean; issues: string[] }>();

    // Validate each section
    for (const section of content.sections) {
      const sectionIssues: string[] = [];
      let sectionIsValid = true;

      // Check word limit
      if (section.wordLimit) {
        const { exceeds, overage } = exceedsWordLimit(section.content, section.wordLimit);
        if (exceeds) {
          sectionIssues.push(`Exceeds word limit by ${overage} words`);
          if (overage > section.wordLimit * 0.1) {
            // More than 10% over is an error
            errors.push(`Section "${section.title}" exceeds word limit by ${overage} words`);
            sectionIsValid = false;
          } else {
            warnings.push(`Section "${section.title}" slightly exceeds word limit`);
          }
        }
      }

      // Check for required sections with empty content
      if (section.isRequired && section.wordCount < 50) {
        errors.push(`Required section "${section.title}" has insufficient content`);
        sectionIssues.push('Insufficient content');
        sectionIsValid = false;
      }

      // Check for placeholder text
      if (this.containsPlaceholderText(section.content)) {
        warnings.push(`Section "${section.title}" may contain placeholder text`);
        sectionIssues.push('May contain placeholder text');
      }

      sectionValidation.set(section.id, {
        isValid: sectionIsValid,
        issues: sectionIssues,
      });
    }

    // Document-level validation
    const requiredSectionTypes = this.getRequiredSectionTypes(docType);
    for (const requiredType of requiredSectionTypes) {
      const hasSection = content.sections.some((s) => s.type === requiredType);
      if (!hasSection) {
        errors.push(`Missing required section: ${requiredType}`);
      }
    }

    // Check total word count for documents with limits
    const totalLimit = this.getTotalWordLimit(docType);
    if (totalLimit && content.totalWordCount > totalLimit) {
      warnings.push(`Total document length (${content.totalWordCount}) approaches limit (${totalLimit})`);
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      sectionValidation,
    };
  }

  // ============================================================================
  // Helper Methods
  // ============================================================================

  /**
   * Validate that all prerequisites are met for document generation
   */
  private validatePrerequisites(project: Project): void {
    if (!project.intake) {
      throw new Error('Project intake data is required for document generation');
    }

    if (!project.classification) {
      throw new Error('Project classification is required for document generation');
    }

    // Methodology is required for most documents
    if (!project.methodology && project.classification.projectType !== 'QI') {
      throw new Error('Methodology stage must be completed before document generation');
    }

    // Ethics is required for research projects
    if (!project.ethics && project.classification.projectType !== 'QI') {
      throw new Error('Ethics stage must be completed before document generation');
    }
  }

  /**
   * Get section configurations for a document type
   */
  private getSectionConfigs(docType: DocumentType, project: Project): SectionConfig[] {
    switch (docType) {
      case DocumentType.RESEARCH_PROTOCOL:
        return this.getProtocolSections(project);

      case DocumentType.QI_PROJECT_PLAN:
        return this.getQIPlanSections(project);

      case DocumentType.EMF_APPLICATION_JUMPSTART:
      case DocumentType.EMF_APPLICATION_LEADING_EDGE:
      case DocumentType.EMF_APPLICATION_TRANSLATED:
        return this.getEMFSections(docType, project);

      case DocumentType.HREC_COVER_LETTER:
        return this.getHRECCoverLetterSections(project);

      case DocumentType.PICF:
        return this.getPICFSections(project);

      case DocumentType.DATA_MANAGEMENT_PLAN:
        return this.getDataManagementPlanSections(project);

      case DocumentType.LNR_APPLICATION:
        return this.getLNRApplicationSections(project);

      default:
        return this.getGenericSections(docType, project);
    }
  }

  /**
   * Get sections for research protocol
   */
  private getProtocolSections(_project: Project): SectionConfig[] {
    return [
      {
        name: 'title_page',
        title: 'Title Page',
        sectionType: SectionType.TITLE_PAGE,
        sourceFields: ['intake.projectTitle', 'intake.principalInvestigator'],
        isRequired: true,
      },
      {
        name: 'synopsis',
        title: 'Protocol Synopsis',
        sectionType: SectionType.SYNOPSIS,
        sourceFields: ['intake', 'methodology.studyDesign', 'methodology.outcomes'],
        wordLimit: PROTOCOL_WORD_LIMITS.sections.synopsis,
        isRequired: true,
      },
      {
        name: 'introduction',
        title: 'Introduction',
        sectionType: SectionType.INTRODUCTION,
        sourceFields: ['intake.clinicalProblem', 'research.gapAnalysis'],
        wordLimit: PROTOCOL_WORD_LIMITS.sections.introduction,
        isRequired: true,
      },
      {
        name: 'background',
        title: 'Background and Rationale',
        sectionType: SectionType.BACKGROUND,
        sourceFields: ['research.evidenceSynthesis', 'research.gapAnalysis', 'research.citations'],
        wordLimit: PROTOCOL_WORD_LIMITS.sections.background,
        isRequired: true,
      },
      {
        name: 'aims_objectives',
        title: 'Aims and Objectives',
        sectionType: SectionType.AIMS_OBJECTIVES,
        sourceFields: ['intake.intendedOutcomes', 'methodology.outcomes'],
        isRequired: true,
      },
      {
        name: 'methods',
        title: 'Methods',
        sectionType: SectionType.METHODS,
        sourceFields: ['methodology.studyDesign', 'methodology.procedures', 'methodology.analysisPlan'],
        wordLimit: PROTOCOL_WORD_LIMITS.sections.methods,
        isRequired: true,
      },
      {
        name: 'participants',
        title: 'Participants',
        sectionType: SectionType.PARTICIPANTS,
        sourceFields: ['methodology.participants', 'intake.targetPopulation'],
        isRequired: true,
      },
      {
        name: 'outcomes',
        title: 'Outcome Measures',
        sectionType: SectionType.OUTCOMES,
        sourceFields: ['methodology.outcomes'],
        isRequired: true,
      },
      {
        name: 'procedures',
        title: 'Study Procedures',
        sectionType: SectionType.PROCEDURES,
        sourceFields: ['methodology.procedures', 'methodology.dataCollection'],
        isRequired: true,
      },
      {
        name: 'data_management',
        title: 'Data Management',
        sectionType: SectionType.DATA_MANAGEMENT,
        sourceFields: ['ethics.dataGovernance', 'methodology.dataCollection'],
        isRequired: true,
      },
      {
        name: 'ethical_considerations',
        title: 'Ethical Considerations',
        sectionType: SectionType.ETHICAL_CONSIDERATIONS,
        sourceFields: ['ethics.ethicsPathway', 'ethics.riskAssessment', 'ethics.consentRequirements'],
        isRequired: true,
      },
      {
        name: 'timeline',
        title: 'Timeline',
        sectionType: SectionType.TIMELINE,
        sourceFields: ['methodology.timeline', 'intake.timelineConstraint'],
        isRequired: true,
      },
      {
        name: 'references',
        title: 'References',
        sectionType: SectionType.REFERENCES,
        sourceFields: ['research.citations'],
        isRequired: true,
      },
    ];
  }

  /**
   * Get sections for QI project plan
   */
  private getQIPlanSections(_project: Project): SectionConfig[] {
    return [
      {
        name: 'title_page',
        title: 'Title Page',
        sectionType: SectionType.TITLE_PAGE,
        sourceFields: ['intake.projectTitle', 'intake.principalInvestigator'],
        isRequired: true,
      },
      {
        name: 'problem_statement',
        title: 'Problem Statement',
        sectionType: SectionType.INTRODUCTION,
        sourceFields: ['intake.clinicalProblem', 'intake.conceptDescription'],
        isRequired: true,
      },
      {
        name: 'aims',
        title: 'SMART Aims',
        sectionType: SectionType.AIMS_OBJECTIVES,
        sourceFields: ['intake.intendedOutcomes'],
        isRequired: true,
      },
      {
        name: 'intervention',
        title: 'Intervention Description',
        sectionType: SectionType.METHODS,
        sourceFields: ['methodology.procedures', 'intake.conceptDescription'],
        isRequired: true,
      },
      {
        name: 'measures',
        title: 'Measures',
        sectionType: SectionType.OUTCOMES,
        sourceFields: ['methodology.outcomes'],
        isRequired: true,
      },
      {
        name: 'timeline',
        title: 'Timeline and PDSA Cycles',
        sectionType: SectionType.TIMELINE,
        sourceFields: ['methodology.timeline'],
        isRequired: true,
      },
      {
        name: 'sustainability',
        title: 'Sustainability Plan',
        sectionType: SectionType.DISSEMINATION,
        sourceFields: ['intake.intendedOutcomes'],
        isRequired: true,
      },
    ];
  }

  /**
   * Get sections for EMF grant application
   */
  private getEMFSections(_docType: DocumentType, _project: Project): SectionConfig[] {
    return [
      {
        name: 'A4_plain_language_summary',
        title: 'Plain Language Summary',
        sectionType: SectionType.SYNOPSIS,
        sourceFields: ['intake.conceptDescription', 'intake.clinicalProblem'],
        wordLimit: EMF_WORD_LIMITS.sections.A4_plain_language_summary,
        isRequired: true,
      },
      {
        name: 'A5_scientific_abstract',
        title: 'Scientific Abstract',
        sectionType: SectionType.SYNOPSIS,
        sourceFields: ['intake', 'methodology', 'research.gapAnalysis'],
        wordLimit: EMF_WORD_LIMITS.sections.A5_scientific_abstract,
        isRequired: true,
      },
      {
        name: 'B1_background_rationale',
        title: 'Background and Rationale',
        sectionType: SectionType.BACKGROUND,
        sourceFields: ['research.evidenceSynthesis', 'research.gapAnalysis', 'research.citations'],
        wordLimit: EMF_WORD_LIMITS.sections.B1_background_rationale,
        isRequired: true,
      },
      {
        name: 'B2_aims_objectives',
        title: 'Aims and Objectives',
        sectionType: SectionType.AIMS_OBJECTIVES,
        sourceFields: ['intake.intendedOutcomes', 'methodology.outcomes'],
        wordLimit: EMF_WORD_LIMITS.sections.B2_aims_objectives,
        isRequired: true,
      },
      {
        name: 'B3_design_methods',
        title: 'Design and Methods',
        sectionType: SectionType.METHODS,
        sourceFields: ['methodology'],
        wordLimit: EMF_WORD_LIMITS.sections.B3_design_methods,
        isRequired: true,
      },
      {
        name: 'B4_innovation_impact',
        title: 'Innovation and Impact',
        sectionType: SectionType.DISSEMINATION,
        sourceFields: ['research.gapAnalysis', 'intake.intendedOutcomes'],
        wordLimit: EMF_WORD_LIMITS.sections.B4_innovation_impact,
        isRequired: true,
      },
      {
        name: 'B5_translation_plan',
        title: 'Translation Plan',
        sectionType: SectionType.DISSEMINATION,
        sourceFields: ['intake.intendedOutcomes'],
        wordLimit: EMF_WORD_LIMITS.sections.B5_translation_plan,
        isRequired: true,
      },
    ];
  }

  /**
   * Get sections for HREC cover letter
   */
  private getHRECCoverLetterSections(_project: Project): SectionConfig[] {
    return [
      {
        name: 'introduction',
        title: 'Introduction',
        sectionType: SectionType.INTRODUCTION,
        sourceFields: ['intake.projectTitle', 'intake.principalInvestigator'],
        isRequired: true,
      },
      {
        name: 'project_summary',
        title: 'Project Summary',
        sectionType: SectionType.SYNOPSIS,
        sourceFields: ['intake.conceptDescription', 'methodology.studyDesign'],
        wordLimit: 300,
        isRequired: true,
      },
      {
        name: 'ethical_considerations',
        title: 'Key Ethical Considerations',
        sectionType: SectionType.ETHICAL_CONSIDERATIONS,
        sourceFields: ['ethics.riskAssessment', 'ethics.consentRequirements'],
        isRequired: true,
      },
      {
        name: 'request',
        title: 'Request for Review',
        sectionType: SectionType.APPENDIX,
        sourceFields: ['ethics.ethicsPathway'],
        isRequired: true,
      },
    ];
  }

  /**
   * Get sections for PICF
   */
  private getPICFSections(_project: Project): SectionConfig[] {
    return [
      {
        name: 'introduction',
        title: 'Introduction',
        sectionType: SectionType.INTRODUCTION,
        sourceFields: ['intake.projectTitle'],
        isRequired: true,
      },
      {
        name: 'purpose',
        title: 'Purpose of the Study',
        sectionType: SectionType.AIMS_OBJECTIVES,
        sourceFields: ['intake.conceptDescription', 'intake.intendedOutcomes'],
        isRequired: true,
      },
      {
        name: 'participation',
        title: 'What Participation Involves',
        sectionType: SectionType.PROCEDURES,
        sourceFields: ['methodology.procedures'],
        isRequired: true,
      },
      {
        name: 'risks_benefits',
        title: 'Risks and Benefits',
        sectionType: SectionType.ETHICAL_CONSIDERATIONS,
        sourceFields: ['ethics.riskAssessment'],
        isRequired: true,
      },
      {
        name: 'privacy',
        title: 'Privacy and Confidentiality',
        sectionType: SectionType.DATA_MANAGEMENT,
        sourceFields: ['ethics.dataGovernance'],
        isRequired: true,
      },
      {
        name: 'voluntary',
        title: 'Voluntary Participation',
        sectionType: SectionType.ETHICAL_CONSIDERATIONS,
        sourceFields: ['ethics.consentRequirements'],
        isRequired: true,
      },
      {
        name: 'contact',
        title: 'Contact Information',
        sectionType: SectionType.APPENDIX,
        sourceFields: ['intake.principalInvestigator'],
        isRequired: true,
      },
    ];
  }

  /**
   * Get sections for Data Management Plan
   */
  private getDataManagementPlanSections(_project: Project): SectionConfig[] {
    return [
      {
        name: 'data_types',
        title: 'Data Types and Sources',
        sectionType: SectionType.DATA_MANAGEMENT,
        sourceFields: ['ethics.dataGovernance', 'methodology.dataCollection'],
        isRequired: true,
      },
      {
        name: 'collection',
        title: 'Data Collection Methods',
        sectionType: SectionType.PROCEDURES,
        sourceFields: ['methodology.dataCollection', 'methodology.procedures'],
        isRequired: true,
      },
      {
        name: 'storage_security',
        title: 'Storage and Security',
        sectionType: SectionType.DATA_MANAGEMENT,
        sourceFields: ['ethics.dataGovernance'],
        isRequired: true,
      },
      {
        name: 'access_sharing',
        title: 'Access and Sharing',
        sectionType: SectionType.DATA_MANAGEMENT,
        sourceFields: ['ethics.dataGovernance'],
        isRequired: true,
      },
      {
        name: 'retention',
        title: 'Retention and Disposal',
        sectionType: SectionType.DATA_MANAGEMENT,
        sourceFields: ['ethics.dataGovernance'],
        isRequired: true,
      },
    ];
  }

  /**
   * Get sections for LNR application
   */
  private getLNRApplicationSections(_project: Project): SectionConfig[] {
    return [
      {
        name: 'project_details',
        title: 'Project Details',
        sectionType: SectionType.INTRODUCTION,
        sourceFields: ['intake'],
        isRequired: true,
      },
      {
        name: 'research_plan',
        title: 'Research Plan',
        sectionType: SectionType.METHODS,
        sourceFields: ['methodology'],
        isRequired: true,
      },
      {
        name: 'risk_assessment',
        title: 'Risk Assessment',
        sectionType: SectionType.ETHICAL_CONSIDERATIONS,
        sourceFields: ['ethics.riskAssessment'],
        isRequired: true,
      },
      {
        name: 'data_management',
        title: 'Data Management',
        sectionType: SectionType.DATA_MANAGEMENT,
        sourceFields: ['ethics.dataGovernance'],
        isRequired: true,
      },
    ];
  }

  /**
   * Get generic sections for other document types
   */
  private getGenericSections(_docType: DocumentType, _project: Project): SectionConfig[] {
    return [
      {
        name: 'introduction',
        title: 'Introduction',
        sectionType: SectionType.INTRODUCTION,
        sourceFields: ['intake'],
        isRequired: true,
      },
      {
        name: 'content',
        title: 'Main Content',
        sectionType: SectionType.METHODS,
        sourceFields: ['intake', 'methodology'],
        isRequired: true,
      },
    ];
  }

  /**
   * Build source content object from project data
   */
  private buildSourceContent(project: Project, sourceFields: string[]): Record<string, unknown> {
    const content: Record<string, unknown> = {};

    for (const field of sourceFields) {
      const value = this.getNestedValue(project as unknown as Record<string, unknown>, field);
      if (value !== undefined) {
        content[field] = value;
      }
    }

    return content;
  }

  /**
   * Get nested value from object using dot notation
   */
  private getNestedValue(obj: Record<string, unknown>, path: string): unknown {
    const parts = path.split('.');
    let current: unknown = obj;

    for (const part of parts) {
      if (current === undefined || current === null) {
        return undefined;
      }
      current = (current as Record<string, unknown>)[part];
    }

    return current;
  }

  /**
   * Get writing style for a specific section
   */
  private getWritingStyleForSection(
    docType: DocumentType,
    sectionName: string,
    config: DocumentGenerationConfig
  ): WritingStyle {
    // Plain language sections
    const plainLanguageSections = [
      'A4_plain_language_summary',
      'plain_language_summary',
      'introduction', // For PICF
      'participation',
      'voluntary',
    ];

    if (docType === DocumentType.PICF) {
      return WritingStyle.PLAIN_LANGUAGE;
    }

    if (plainLanguageSections.includes(sectionName)) {
      return WritingStyle.PLAIN_LANGUAGE;
    }

    // EMF grant sections should be persuasive where appropriate
    if (
      docType === DocumentType.EMF_APPLICATION_LEADING_EDGE ||
      docType === DocumentType.EMF_APPLICATION_JUMPSTART
    ) {
      if (sectionName === 'B4_innovation_impact' || sectionName === 'B5_translation_plan') {
        return WritingStyle.FORMAL;
      }
    }

    return config.style;
  }

  /**
   * Map internal WritingStyle to prompt WritingStyle
   */
  private mapToPromptWritingStyle(style: WritingStyle): PromptWritingStyle {
    const mapping: Record<WritingStyle, PromptWritingStyle> = {
      [WritingStyle.SCIENTIFIC]: 'SCIENTIFIC',
      [WritingStyle.PLAIN_LANGUAGE]: 'PLAIN_LANGUAGE',
      [WritingStyle.FORMAL]: 'FORMAL',
      [WritingStyle.TECHNICAL]: 'SCIENTIFIC',
    };
    return mapping[style] || 'SCIENTIFIC';
  }

  /**
   * Map internal DocumentType to prompt DocumentType
   */
  private mapToPromptDocumentType(
    docType: DocumentType
  ): 'RESEARCH_PROTOCOL' | 'QI_PROJECT_PLAN' | 'EMF_GRANT_APPLICATION' | 'HREC_COVER_LETTER' | 'PARTICIPANT_INFORMATION_SHEET' | 'DATA_MANAGEMENT_PLAN' | 'PLAIN_LANGUAGE_SUMMARY' {
    const mapping: Record<string, 'RESEARCH_PROTOCOL' | 'QI_PROJECT_PLAN' | 'EMF_GRANT_APPLICATION' | 'HREC_COVER_LETTER' | 'PARTICIPANT_INFORMATION_SHEET' | 'DATA_MANAGEMENT_PLAN' | 'PLAIN_LANGUAGE_SUMMARY'> = {
      [DocumentType.RESEARCH_PROTOCOL]: 'RESEARCH_PROTOCOL',
      [DocumentType.QI_PROJECT_PLAN]: 'QI_PROJECT_PLAN',
      [DocumentType.EMF_APPLICATION_JUMPSTART]: 'EMF_GRANT_APPLICATION',
      [DocumentType.EMF_APPLICATION_LEADING_EDGE]: 'EMF_GRANT_APPLICATION',
      [DocumentType.EMF_APPLICATION_TRANSLATED]: 'EMF_GRANT_APPLICATION',
      [DocumentType.HREC_COVER_LETTER]: 'HREC_COVER_LETTER',
      [DocumentType.PICF]: 'PARTICIPANT_INFORMATION_SHEET',
      [DocumentType.DATA_MANAGEMENT_PLAN]: 'DATA_MANAGEMENT_PLAN',
      [DocumentType.LNR_APPLICATION]: 'RESEARCH_PROTOCOL',
    };
    return mapping[docType] || 'RESEARCH_PROTOCOL';
  }

  /**
   * Format parsed outline to text
   */
  private formatOutlineToText(outline: DocumentOutlineOutput): string {
    let text = '';

    for (const section of outline.sections) {
      const indent = '  '.repeat(section.level - 1);
      text += `${indent}${section.id}. ${section.title}\n`;

      for (const point of section.keyPoints) {
        text += `${indent}  - ${point}\n`;
      }

      if (section.notes) {
        text += `${indent}  [Note: ${section.notes}]\n`;
      }

      text += '\n';
    }

    if (outline.requiredAppendices.length > 0) {
      text += '\nRequired Appendices:\n';
      for (const appendix of outline.requiredAppendices) {
        text += `  - ${appendix}\n`;
      }
    }

    return text;
  }

  /**
   * Generate fallback outline when LLM fails
   */
  private generateFallbackOutline(
    sectionName: string,
    sourceContent: Record<string, unknown>
  ): string {
    const keys = Object.keys(sourceContent);
    let outline = `${sectionName}\n\n`;

    outline += 'Key points to address:\n';
    for (const key of keys) {
      outline += `  - Content from ${key}\n`;
    }

    return outline;
  }

  /**
   * Compile validation result from section validations
   */
  private compileValidationResult(
    sections: DocumentSectionContent[],
    _docType: DocumentType
  ): DocumentValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    for (const section of sections) {
      for (const error of section.validationErrors) {
        if (error.includes('exceeds word limit')) {
          // Determine if it's an error or warning based on overage
          const match = error.match(/(\d+) over/);
          if (match && match[1] && section.wordLimit) {
            const overage = parseInt(match[1], 10);
            if (overage > section.wordLimit * 0.1) {
              errors.push(`${section.title}: ${error}`);
            } else {
              warnings.push(`${section.title}: ${error}`);
            }
          }
        } else {
          errors.push(`${section.title}: ${error}`);
        }
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Check if content contains placeholder text
   */
  private containsPlaceholderText(content: string): boolean {
    const placeholderPatterns = [
      /\[INSERT.*?\]/i,
      /\[TODO.*?\]/i,
      /\[PLACEHOLDER.*?\]/i,
      /\{\{.*?\}\}/,
      /TBD/i,
      /XXXX/,
      /\[.*?to be added.*?\]/i,
    ];

    return placeholderPatterns.some((pattern) => pattern.test(content));
  }

  /**
   * Get required section types for a document type
   */
  private getRequiredSectionTypes(docType: DocumentType): SectionType[] {
    switch (docType) {
      case DocumentType.RESEARCH_PROTOCOL:
        return [
          SectionType.TITLE_PAGE,
          SectionType.SYNOPSIS,
          SectionType.INTRODUCTION,
          SectionType.BACKGROUND,
          SectionType.METHODS,
          SectionType.PARTICIPANTS,
          SectionType.OUTCOMES,
        ];

      case DocumentType.PICF:
        return [
          SectionType.INTRODUCTION,
          SectionType.PROCEDURES,
          SectionType.ETHICAL_CONSIDERATIONS,
          SectionType.DATA_MANAGEMENT,
        ];

      default:
        return [SectionType.INTRODUCTION];
    }
  }

  /**
   * Get total word limit for a document type
   */
  private getTotalWordLimit(docType: DocumentType): number | undefined {
    const limits: Partial<Record<DocumentType, number>> = {
      [DocumentType.EMF_APPLICATION_JUMPSTART]: 5000,
      [DocumentType.EMF_APPLICATION_LEADING_EDGE]: 7000,
      [DocumentType.EMF_APPLICATION_TRANSLATED]: 6000,
    };

    return limits[docType];
  }

  /**
   * Get document title based on type and project
   */
  private getDocumentTitle(docType: DocumentType, project: Project): string {
    const titles: Record<DocumentType, string> = {
      [DocumentType.RESEARCH_PROTOCOL]: `Research Protocol: ${project.intake.projectTitle}`,
      [DocumentType.QI_PROJECT_PLAN]: `QI Project Plan: ${project.intake.projectTitle}`,
      [DocumentType.EMF_APPLICATION_JUMPSTART]: `EMF Jumpstart Application: ${project.intake.projectTitle}`,
      [DocumentType.EMF_APPLICATION_LEADING_EDGE]: `EMF Leading Edge Application: ${project.intake.projectTitle}`,
      [DocumentType.EMF_APPLICATION_TRANSLATED]: `EMF Translated Research Application: ${project.intake.projectTitle}`,
      [DocumentType.HREC_COVER_LETTER]: `HREC Cover Letter: ${project.intake.projectTitle}`,
      [DocumentType.PICF]: `Participant Information and Consent Form: ${project.intake.projectTitle}`,
      [DocumentType.LNR_APPLICATION]: `Low/Negligible Risk Application: ${project.intake.projectTitle}`,
      [DocumentType.DATA_MANAGEMENT_PLAN]: `Data Management Plan: ${project.intake.projectTitle}`,
      [DocumentType.SITE_ASSESSMENT]: `Site Assessment: ${project.intake.projectTitle}`,
      [DocumentType.INVESTIGATOR_AGREEMENT]: `Investigator Agreement: ${project.intake.projectTitle}`,
      [DocumentType.BUDGET_JUSTIFICATION]: `Budget Justification: ${project.intake.projectTitle}`,
      [DocumentType.LITERATURE_REVIEW]: `Literature Review: ${project.intake.projectTitle}`,
      [DocumentType.REFERENCE_LIST]: `Reference List: ${project.intake.projectTitle}`,
      [DocumentType.TIMELINE]: `Project Timeline: ${project.intake.projectTitle}`,
      [DocumentType.CONSENT_FORM]: `Consent Form: ${project.intake.projectTitle}`,
      [DocumentType.OTHER]: `Document: ${project.intake.projectTitle}`,
    };

    return titles[docType] || `Document: ${project.intake.projectTitle}`;
  }

  /**
   * Save document to database
   */
  private async saveDocument(
    projectId: string,
    content: DocumentContent,
    validationResult: ValidationResult
  ): Promise<GeneratedDocument> {

    // Convert sections to database format
    const sections: DocumentSection[] = content.sections.map((s) => ({
      id: s.id,
      type: s.type,
      title: s.title,
      content: s.content,
      wordCount: s.wordCount,
      wordLimit: s.wordLimit,
      order: s.order,
      isRequired: s.isRequired,
      sourceFields: s.sourceFields,
      validationErrors: s.validationErrors,
    }));

    const createDTO: CreateDocumentDTO = {
      type: content.type,
      filename: generateFilename(content.type, content.title, '1.0', DocumentFormat.DOCX),
      path: `/outputs/${projectId}/${content.type.toLowerCase()}/`,
      format: DocumentFormat.DOCX,
      status: validationResult.isValid ? DocumentStatus.DRAFT : DocumentStatus.DRAFT,
      version: '1.0',
      sections,
      validationResult: {
        isValid: validationResult.isValid,
        errors: validationResult.errors,
        warnings: validationResult.warnings,
      },
    };

    return this.documentRepo.createForProject(projectId, createDTO);
  }

  /**
   * Create submission package metadata
   */
  private async createSubmissionMetadata(
    projectId: string,
    project: Project,
    documents: GeneratedDocument[],
    requiredTypes: DocumentType[]
  ): Promise<DocumentMetadata> {
    // Build submission checklist
    const checklist: SubmissionChecklistItem[] = requiredTypes.map((docType) => {
      const doc = documents.find((d) => d.type === docType);
      return {
        item: this.getDocumentTitle(docType, project),
        required: true,
        completed: doc !== undefined,
        documentType: docType,
      };
    });

    // Calculate totals
    const totalWordCount = documents.reduce((sum: number, doc: GeneratedDocument) => {
      const sectionWords = doc.sections?.reduce(
        (s: number, sec: DocumentSection) => s + sec.wordCount,
        0
      ) ?? 0;
      return sum + sectionWords;
    }, 0);

    return {
      projectId,
      totalDocuments: documents.length,
      totalWordCount,
      generatedAt: new Date().toISOString(),
      generatedBy: 'system',
      submissionChecklist: checklist,
      packageInfo: {
        packagePath: `/outputs/${projectId}/submission-package.zip`,
      },
    };
  }
}

// ============================================================================
// Supporting Types
// ============================================================================

/**
 * Configuration for a document section
 */
interface SectionConfig {
  /** Section name/identifier */
  name: string;
  /** Display title */
  title: string;
  /** Section type */
  sectionType: SectionType;
  /** Source fields from project data */
  sourceFields: string[];
  /** Word limit for section */
  wordLimit?: number;
  /** Whether section is required */
  isRequired: boolean;
}

// Export the agent class as default
export default DocumentAgent;
