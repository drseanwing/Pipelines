/**
 * References database queries
 * Phase 2.17 - Database Queries - References
 */

import { getPool, getClient } from '../client.js';
import type { ProcessedArticle } from '../../types/index.js';

/**
 * Create a single reference record
 * @param ref - Reference data (without id which is auto-generated)
 * @param projectId - Project UUID to associate the reference with
 * @returns Promise resolving to the created reference with ID
 */
export async function createReference(
  ref: Omit<ProcessedArticle, 'id'>,
  projectId: string
): Promise<ProcessedArticle> {
  const pool = getPool();

  const query = `
    INSERT INTO references (
      project_id,
      pmid,
      doi,
      title,
      authors,
      journal,
      year,
      abstract,
      relevance_score,
      key_findings,
      citation_formatted
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
    RETURNING *
  `;

  const values = [
    projectId,
    ref.pmid || null,
    ref.doi || null,
    ref.title,
    JSON.stringify(ref.authors),
    ref.journal || null,
    ref.year || null,
    ref.abstract || null,
    ref.relevance_score,
    ref.key_findings ? JSON.stringify(ref.key_findings) : null,
    ref.citation_formatted,
  ];

  try {
    const result = await pool.query(query, values);
    return mapRowToReference(result.rows[0]);
  } catch (error) {
    console.error('Error creating reference:', error);
    throw new Error(`Failed to create reference: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Bulk insert multiple references in a single transaction
 * @param refs - Array of reference data
 * @param projectId - Project UUID to associate references with
 */
export async function bulkInsertReferences(
  refs: Omit<ProcessedArticle, 'id'>[],
  projectId: string
): Promise<void> {
  if (refs.length === 0) {
    return;
  }

  const client = await getClient();

  try {
    await client.query('BEGIN');

    const query = `
      INSERT INTO references (
        project_id,
        pmid,
        doi,
        title,
        authors,
        journal,
        year,
        abstract,
        relevance_score,
        key_findings,
        citation_formatted
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
    `;

    for (const ref of refs) {
      const values = [
        projectId,
        ref.pmid || null,
        ref.doi || null,
        ref.title,
        JSON.stringify(ref.authors),
        ref.journal || null,
        ref.year || null,
        ref.abstract || null,
        ref.relevance_score,
        ref.key_findings ? JSON.stringify(ref.key_findings) : null,
        ref.citation_formatted,
      ];

      await client.query(query, values);
    }

    await client.query('COMMIT');
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error bulk inserting references:', error);
    throw new Error(`Failed to bulk insert references: ${error instanceof Error ? error.message : 'Unknown error'}`);
  } finally {
    client.release();
  }
}

/**
 * Get all references for a specific project
 * @param projectId - Project UUID
 * @returns Promise resolving to array of references
 */
export async function getReferencesByProject(projectId: string): Promise<ProcessedArticle[]> {
  const pool = getPool();

  const query = `
    SELECT id, project_id, pmid, doi, title, authors, journal, year,
           abstract, relevance_score, key_findings, citation_formatted, created_at
    FROM references
    WHERE project_id = $1
    ORDER BY relevance_score DESC, year DESC
  `;

  try {
    const result = await pool.query(query, [projectId]);
    return result.rows.map(mapRowToReference);
  } catch (error) {
    console.error('Error fetching references by project:', error);
    throw new Error(`Failed to fetch references: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Update the relevance score of a reference
 * @param id - Reference ID (UUID generated by database)
 * @param score - New relevance score (0.0 - 1.0)
 */
export async function updateReferenceRelevance(
  id: string,
  score: number
): Promise<void> {
  const pool = getPool();

  const query = `
    UPDATE references
    SET relevance_score = $1
    WHERE id = $2
  `;

  try {
    const result = await pool.query(query, [score, id]);
    if (result.rowCount === 0) {
      throw new Error('Reference not found');
    }
  } catch (error) {
    console.error('Error updating reference relevance:', error);
    throw new Error(`Failed to update reference relevance: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Get references by relevance score threshold
 * @param projectId - Project UUID
 * @param minScore - Minimum relevance score (e.g., 0.7 for primary literature)
 * @returns Promise resolving to array of references
 */
export async function getReferencesByRelevance(
  projectId: string,
  minScore: number
): Promise<ProcessedArticle[]> {
  const pool = getPool();

  const query = `
    SELECT id, project_id, pmid, doi, title, authors, journal, year,
           abstract, relevance_score, key_findings, citation_formatted, created_at
    FROM references
    WHERE project_id = $1 AND relevance_score >= $2
    ORDER BY relevance_score DESC, year DESC
  `;

  try {
    const result = await pool.query(query, [projectId, minScore]);
    return result.rows.map(mapRowToReference);
  } catch (error) {
    console.error('Error fetching references by relevance:', error);
    throw new Error(`Failed to fetch references: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Delete a reference
 * @param id - Reference ID (UUID)
 */
export async function deleteReference(id: string): Promise<void> {
  const pool = getPool();

  const query = `
    DELETE FROM references
    WHERE id = $1
  `;

  try {
    const result = await pool.query(query, [id]);
    if (result.rowCount === 0) {
      throw new Error('Reference not found');
    }
  } catch (error) {
    console.error('Error deleting reference:', error);
    throw new Error(`Failed to delete reference: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Find reference by DOI to check for duplicates
 * @param projectId - Project UUID
 * @param doi - DOI to search for
 * @returns Promise resolving to the reference or null if not found
 */
export async function findReferenceByDOI(
  projectId: string,
  doi: string
): Promise<ProcessedArticle | null> {
  const pool = getPool();

  const query = `
    SELECT id, project_id, pmid, doi, title, authors, journal, year,
           abstract, relevance_score, key_findings, citation_formatted, created_at
    FROM references
    WHERE project_id = $1 AND doi = $2
    LIMIT 1
  `;

  try {
    const result = await pool.query(query, [projectId, doi]);
    if (result.rows.length === 0) {
      return null;
    }
    return mapRowToReference(result.rows[0]);
  } catch (error) {
    console.error('Error finding reference by DOI:', error);
    throw new Error(`Failed to find reference: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Map database row to ProcessedArticle type
 * @param row - Database row
 * @returns ProcessedArticle object
 */
function mapRowToReference(row: any): ProcessedArticle {
  return {
    id: row.id,
    pmid: row.pmid || undefined,
    doi: row.doi || undefined,
    title: row.title,
    authors: row.authors,
    journal: row.journal || undefined,
    year: row.year || undefined,
    abstract: row.abstract || undefined,
    relevance_score: row.relevance_score,
    key_findings: row.key_findings || undefined,
    methodology_notes: row.methodology_notes || undefined,
    limitations: row.limitations || undefined,
    full_text_available: row.full_text_available || false,
    citation_formatted: row.citation_formatted,
  };
}
